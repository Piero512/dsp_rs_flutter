/*! \file */
/*******************************************
 *                                         *
 *  File auto-generated by `::safer_ffi`.  *
 *                                         *
 *  Do not manually edit this file.        *
 *                                         *
 *******************************************/

#ifndef __RUST_DSP__
#define __RUST_DSP__

#ifdef __cplusplus
extern "C" {
#endif


#include <stddef.h>
#include <stdint.h>

typedef struct ForwardFFTHandle ForwardFFTHandle_t;

/** \brief
 *  Get a new forward FFT handle
 */
ForwardFFTHandle_t * forward_fft_handle_new (
    uint64_t sample_size);

/** \brief
 *  Free the handle
 */
void forward_fft_handle_free (
    ForwardFFTHandle_t * p);

/** \brief
 *  `&'lt [T]` but with a guaranteed `#[repr(C)]` layout.
 * 
 *  # C layout (for some given type T)
 * 
 *  ```c
 *  typedef struct {
 *      // Cannot be NULL
 *      T * ptr;
 *      size_t len;
 *  } slice_T;
 *  ```
 * 
 *  # Nullable pointer?
 * 
 *  If you want to support the above typedef, but where the `ptr` field is
 *  allowed to be `NULL` (with the contents of `len` then being undefined)
 *  use the `Option< slice_ptr<_> >` type.
 */
typedef struct {

    float const * ptr;

    size_t len;

} slice_ref_float_t;

/** \brief
 *  Same as [`Vec<T>`][`rust::Vec`], but with guaranteed `#[repr(C)]` layout
 */
typedef struct {

    float * ptr;

    size_t len;

    size_t cap;

} Vec_float_t;

/** \brief
 *  Calculate a real-valued FFT and return the values on 
 */
Vec_float_t dsprs_forward_fft_process_real (
    ForwardFFTHandle_t * fft,
    slice_ref_float_t input);

typedef struct SignalHandle SignalHandle_t;

SignalHandle_t * dsprs_signal_new (
    slice_ref_float_t data,
    size_t sample_rate);

SignalHandle_t * dsprs_signal_empty (
    uint64_t sample_rate);

void dsprs_signal_free (
    SignalHandle_t * to_free);

SignalHandle_t * dsprs_signal_rescale (
    SignalHandle_t const * signal,
    float amount);

ForwardFFTHandle_t * dsprs_forward_fft_new (
    uint64_t sample_size);

typedef struct SpectrumHandle SpectrumHandle_t;

SpectrumHandle_t * dsprs_forward_fft_process (
    ForwardFFTHandle_t * fft,
    SignalHandle_t const * signal);

typedef struct WindowHandle WindowHandle_t;

/** \brief
 *  Window Functions
 *  Create a rectangular window handle
 */
WindowHandle_t * dsprs_rectangular_window (
    uint64_t width,
    uint64_t offset,
    uint64_t window_length);

/** \brief
 *  Create a triangular window handle
 */
WindowHandle_t * dsprs_triangular_window (
    uint64_t width,
    uint64_t offset,
    uint64_t window_length);

/** \brief
 *  Create a welch window handle
 */
WindowHandle_t * dsprs_welch_window (
    uint64_t width,
    uint64_t offset,
    uint64_t window_length);

/** \brief
 *  Create a sine window handle.
 */
WindowHandle_t * dsprs_sine_window (
    uint64_t width,
    uint64_t offset,
    uint64_t window_length);

/** \brief
 *  Create a hann window handle
 */
WindowHandle_t * dsprs_hann_window (
    uint64_t width,
    uint64_t offset,
    uint64_t window_length);

/** \brief
 *  Create a hamming window handle
 */
WindowHandle_t * dsprs_hamming_window (
    uint64_t width,
    uint64_t offset,
    uint64_t window_length);

/** \brief
 *  Create a blackman window handle
 */
WindowHandle_t * dsprs_blackman_window (
    uint64_t width,
    uint64_t offset,
    uint64_t window_length);

/** \brief
 *  `&'lt mut [T]` but with a guaranteed `#[repr(C)]` layout.
 * 
 *  # C layout (for some given type T)
 * 
 *  ```c
 *  typedef struct {
 *      // Cannot be NULL
 *      T * ptr;
 *      size_t len;
 *  } slice_T;
 *  ```
 * 
 *  # Nullable pointer?
 * 
 *  If you want to support the above typedef, but where the `ptr` field is
 *  allowed to be `NULL` (with the contents of `len` then being undefined)
 *  use the `Option< slice_ptr<_> >` type.
 */
typedef struct {

    float * ptr;

    size_t len;

} slice_mut_float_t;


#include <stdbool.h>

/** \brief
 *  Apply the window to the sample data
 */
bool dsprs_window_apply (
    WindowHandle_t const * window,
    slice_ref_float_t input,
    slice_mut_float_t output);


#ifdef __cplusplus
} /* extern "C" */
#endif

#endif /* __RUST_DSP__ */
